<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C语言 练习详情 - LiQian</title>
    <link rel="stylesheet" href="../css/practice.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <div class="container">
        <nav class="navbar">
            <a href="../code_practice.html" class="nav-brand">
                <i class="fas fa-arrow-left"></i> 返回练习库
            </a>
        </nav>

        <section class="hero-section">
            <h1><i class="fab fa-c"></i> C语言 编程练习</h1>
            <p>算法实现、数据结构练习和日常编码挑战</p>
        </section>

        <div style="padding: 2rem;">
            <!-- 代码示例区域 -->
            <div class="code-section">
				<h3><i class="fas fa-code"></i> 2026.01.13力扣网习题</h3>
                <pre><code class="language-c">
#define _CRT_SECURE_NO_WARNINGS 1

#include stdio.h
#include stdlib.h
#include assert.h
#include stdbool.h

//2026.01.13力扣网刷题
//3745. 三元素表达式的最大值——贪心、数组、枚举、排序、第467场周赛——简单
//给你一个整数数组 nums。
//从 nums 中选择三个元素 a、b 和 c，它们的下标需 互不相同 ，使表达式 a + b - c 的值最大化。
//返回该表达式可能的 最大值 。
//示例 1：
//输入： nums = [1, 4, 2, 5]
//输出： 8
//解释：
//可以选择 a = 4，b = 5，c = 1。表达式的值为 4 + 5 - 1 = 8，这是可能的最大值。
//示例 2：
//输入： nums = [-2, 0, 5, -2, 4]
//输出： 11
//解释：
//可以选择 a = 5，b = 4，c = -2。表达式的值为 5 + 4 - (-2) = 11，这是可能的最大值。
//提示：
//3 <= nums.length <= 100
//- 100 <= nums[i] <= 100

void Count_Sort(int* nums, int len, int max, int min) {
	int* hash = (int*)calloc(max - min + 1, sizeof(int));
	assert(hash);
	for (int i = 0; i < len; i++) {
		int key = nums[i] - min;
		hash[key] += 1;
	}
	for (int i = min, j = 0; i <= max && j < len; i++) {
		while (hash[i - min]) {
			nums[j] = i;
			j += 1;
			hash[i - min] -= 1;
		}
	}
	free(hash);
	hash = NULL;
}

// 计数排序
int maximizeExpressionOfThree(int* nums, int numsSize) {
	int max = nums[0], min = nums[0];
	for (int i = 0; i < numsSize; i++) {
		if (nums[i] > max) {
			max = nums[i];
		}
		else if (nums[i] < min) {
			min = nums[i];
		}
	}
	Count_Sort(nums, numsSize, max, min);
	return nums[numsSize - 1] + nums[numsSize - 2] - nums[0];
}

# 测试示例
int main(){
    int nums[5] = {1, 2, 1, 1, 3};
    int res = maximizeExpressionOfThree(nums, 5);
	printf("%d\n", res);
    return 0;
}
</code></pre>
            </div>

            <!-- 项目信息 -->
            <div class="project-info" style="margin-top: 2rem;">
                <h3><i class="fas fa-info-circle"></i> 项目信息</h3>
                <div class="repo-links">
                    <a href="https://gitee.com/Li_2023-9-13/daily_practice_c"
                       target="_blank" class="repo-link gitee">
                        <i class="fas fa-code"></i> Gitee 仓库
                    </a>
                    <a href="https://github.com/LiQian2023/daily_practice_c"
                       target="_blank" class="repo-link github">
                        <i class="fab fa-github"></i> GitHub 镜像
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- 代码高亮 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="../js/practice.js"></script>
</body>
</html>