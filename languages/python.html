<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python 练习详情 - LiQian</title>
    <link rel="stylesheet" href="../css/practice.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <div class="container">
        <nav class="navbar">
            <a href="../code_practice.html" class="nav-brand">
                <i class="fas fa-arrow-left"></i> 返回练习库
            </a>
        </nav>

        <section class="hero-section">
            <h1><i class="fab fa-python"></i> Python 编程练习</h1>
            <p>算法实现、数据结构练习和日常编码挑战</p>
        </section>

        <div style="padding: 2rem;">
            <!-- 代码示例区域 -->
            <div class="code-section">
                <h3><i class="fas fa-code"></i> 2026.01.12力扣网习题</h3>
                <pre><code class="language-python">
# 2026.01.12力扣网刷题
# 3740. 三个相等元素之间的最小距离 I——数组、哈希表、第475场周赛——简单
# 给你一个整数数组 nums。
# 如果满足 nums[i] == nums[j] == nums[k]，且(i, j, k) 是 3 个 不同 下标，那么三元组(i, j, k) 被称为 有效三元组 。
# 有效三元组 的 距离 被定义为 abs(i - j) + abs(j - k) + abs(k - i)，其中 abs(x) 表示 x 的 绝对值 。
# 返回一个整数，表示 有效三元组 的 最小 可能距离。如果不存在 有效三元组 ，返回 - 1。
# 示例 1：
# 输入： nums = [1, 2, 1, 1, 3]
# 输出： 6
# 解释：
# 最小距离对应的有效三元组是(0, 2, 3) 。
# (0, 2, 3) 是一个有效三元组，因为 nums[0] == nums[2] == nums[3] == 1。它的距离为 abs(0 - 2) + abs(2 - 3) + abs(3 - 0) = 2 + 1 + 3 = 6。
# 示例 2：
# 输入： nums = [1, 1, 2, 3, 2, 1, 2]
# 输出： 8
# 解释：
# 最小距离对应的有效三元组是(2, 4, 6) 。
# (2, 4, 6) 是一个有效三元组，因为 nums[2] == nums[4] == nums[6] == 2。它的距离为 abs(2 - 4) + abs(4 - 6) + abs(6 - 2) = 2 + 2 + 4 = 8。
# 示例 3：
# 输入： nums = [1]
# 输出： - 1
# 解释：
# 不存在有效三元组，因此答案为 - 1。
# 提示：
# 1 <= n == nums.length <= 100
# 1 <= nums[i] <= n

class Solution(object):
    def minimumDistance(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        hash = {}
        for i in range(len(nums)):
            if nums[i] not in hash:
                hash[nums[i]] = [i]
            else:
                hash[nums[i]].append(i)
        ans = -1
        for value in hash.values():
            length = len(value)
            if length >= 3:
                i, tmp = 1, -1
                while i < length - 1:
                    dis = 2 * (value[i + 1] - value[i - 1])
                    if tmp == -1 or dis < tmp:
                        tmp = dis
                    i += 1
                if ans == -1 or tmp < ans:
                    ans = tmp
        return ans

    # 测试示例
    if __name__ == "__main__":
        nums = [1, 2, 1, 1, 3]
        print(f"最小距离: {minimumDistance(nums)}")

</code></pre>
            </div>

            <!-- 项目信息 -->
            <div class="project-info" style="margin-top: 2rem;">
                <h3><i class="fas fa-info-circle"></i> 项目信息</h3>
                <div class="repo-links">
                    <a href="https://gitee.com/Li_2023-9-13/daily_practic_py"
                       target="_blank" class="repo-link gitee">
                        <i class="fas fa-code"></i> Gitee 仓库
                    </a>
                    <a href="https://github.com/LiQian2023/daily_practice_py"
                       target="_blank" class="repo-link github">
                        <i class="fab fa-github"></i> GitHub 镜像
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- 代码高亮 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="../js/practice.js"></script>
</body>
</html>