<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python 练习详情 - LiQian</title>
    <link rel="stylesheet" href="../css/practice.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <div class="container">
        <nav class="navbar">
            <a href="../code_practice.html" class="nav-brand">
                <i class="fas fa-arrow-left"></i> 返回练习库
            </a>
        </nav>

        <section class="hero-section">
            <h1><i class="fab fa-python"></i> Python 编程练习</h1>
            <p>算法实现、数据结构练习和日常编码挑战</p>
        </section>

        <div style="padding: 2rem;">
            <!-- 代码示例区域 -->
            <div class="code-section">
                <h3><i class="fas fa-code"></i> 2026.01.15力扣网习题</h3>
                <pre><code class="language-python">
# 2026.01.15力扣网刷题
# 3769. 二进制反射排序——数组、排序、第479场周赛——简单
# 给你一个整数数组 nums。
# 二进制反射 是对一个 正整数 的二进制表示按顺序反转（忽略前导零）后，将反转得到的二进制数转为十进制的结果。
# 请按每个元素的二进制反射值的 升序 对数组进行排序。如果两个不同的数字具有相同的二进制反射值，则 较小 的原始数字应排在前面。
# 返回排序后的数组。
# 示例 1：
# 输入： nums = [4, 5, 4]
# 输出：[4, 4, 5]
# 解释：
# 二进制反射值为：
# 4 -> (二进制)100 -> (反转)001 -> 1
# 5 -> (二进制)101 -> (反转)101 -> 5
# 4 -> (二进制)100 -> (反转)001 -> 1
# 根据反射值排序为[4, 4, 5]。
# 示例 2：
# 输入： nums = [3, 6, 5, 8]
# 输出：[8, 3, 6, 5]
# 解释：
# 二进制反射值为：
# 3 -> (二进制)11 -> (反转)11 -> 3
# 6 -> (二进制)110 -> (反转)011 -> 3
# 5 -> (二进制)101 -> (反转)101 -> 5
# 8 -> (二进制)1000 -> (反转)0001 -> 1
# 根据反射值排序为[8, 3, 6, 5]。
# 注意，3 和 6 的反射值相同，因此需要按原始值的升序排列。
# 提示：
# 1 <= nums.length <= 100
# 1 <= nums[i] <= 10^9

class Solution(object):
    def sortByReflection(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        def bin_to_dec(num):
            res = 0
            while num:
                res = (res << 1) | (num & 1)
                num >>= 1
            return res
        hash = []
        for num in nums:
            hash.append([num, bin_to_dec(num)])
        hash.sort(key=lambda x: (x[1], x[0]))
        res = []
        for key in hash:
            res.append(key[0])
        return res


    # 测试示例
    if __name__ == "__main__":
        nums = [1, 2, 1, 1, 3]
        print(f"nums: {sortByReflection(nums)}")

</code></pre>
            </div>

            <!-- 项目信息 -->
            <div class="project-info" style="margin-top: 2rem;">
                <h3><i class="fas fa-info-circle"></i> 项目信息</h3>
                <div class="repo-links">
                    <a href="https://gitee.com/Li_2023-9-13/daily_practic_py"
                       target="_blank" class="repo-link gitee">
                        <i class="fas fa-code"></i> Gitee 仓库
                    </a>
                    <a href="https://github.com/LiQian2023/daily_practice_py"
                       target="_blank" class="repo-link github">
                        <i class="fab fa-github"></i> GitHub 镜像
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- 代码高亮 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="../js/practice.js"></script>
</body>
</html>